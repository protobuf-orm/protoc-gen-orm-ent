package app

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"path/filepath"
	"text/template"

	"github.com/protobuf-orm/protobuf-orm/graph"
	"github.com/protobuf-orm/protoc-gen-orm-ent/internal/work"
	"google.golang.org/protobuf/compiler/protogen"
)

type App struct {
	namer *template.Template

	ent protogen.GoImportPath
	gfs map[string]*protogen.GeneratedFile
}

func New(ent protogen.GoImportPath, opts ...Option) (*App, error) {
	a := &App{
		ent: ent,
		gfs: map[string]*protogen.GeneratedFile{},
	}
	for _, opt := range opts {
		opt(a)
	}
	if a.namer == nil {
		a.namer = template.Must(template.New("namer").Parse("ent/{{ .Name }}.go"))
	}

	return a, nil
}

func (a *App) Run(ctx context.Context, p *protogen.Plugin, g *graph.Graph) error {
	ok := true
	handle_err := func(err error) {
		ok = false
	}

	w := work.NewWork()
	for _, f := range p.Files {
		for _, m := range f.Messages {
			w.Imports[m.Desc.FullName()] = m.GoIdent.GoImportPath
			entity, ok := g.Entities[m.Desc.FullName()]
			if !ok {
				continue
			}

			gf, _, err := a.newGeneratedSchemaFile(p, f)
			if err != nil {
				handle_err(err)
				continue
			}

			fw := work.NewFileWork(w, f, entity, gf)
			if err := a.doWork(ctx, fw); err != nil {
				handle_err(err)
				continue
			}
		}
	}
	if !ok {
		return errors.New("some tasks are failed")
	}

	return nil
}

type fileWork struct {
	*work.FileWork
	ent protogen.GoImportPath
}

func (a *App) doWork(ctx context.Context, base *work.FileWork) error {
	w := &fileWork{
		FileWork: base,
		ent:      base.Src.GoImportPath + "/" + a.ent,
	}

	w.xServer()
	rpcs := w.Entity.Rpcs()
	need_pick := false
	if rpcs.HasAdd() {
		w.xAdd()
		need_pick = true
	}
	if rpcs.HasGet() {
		w.xGet()
		w.xSelectKey()
		need_pick = true
	}
	if rpcs.HasPatch() {
		w.xPatch()
		w.xGetKey()
		need_pick = true
	}
	if rpcs.HasErase() {
		w.xErase()
		need_pick = true
	}
	if need_pick {
		w.xPick()
	}

	return nil
}

func (a *App) newGeneratedSchemaFile(p *protogen.Plugin, f *protogen.File) (*protogen.GeneratedFile, string, error) {
	dir, name := filepath.Split(f.GeneratedFilenamePrefix)

	var b bytes.Buffer
	if err := a.namer.Execute(&b, struct{ Name string }{Name: name}); err != nil {
		return nil, "", fmt.Errorf("name %s: %w", f.GeneratedFilenamePrefix, err)
	}
	name = b.String()
	path := filepath.Join(dir, name)

	gf, ok := a.gfs[path]
	if ok {
		return gf, path, nil
	}

	pkg, _ := filepath.Split(path)
	pkg_name := filepath.Base(pkg)

	gf = p.NewGeneratedFile(path, f.GoImportPath+protogen.GoImportPath(pkg))
	a.gfs[path] = gf

	gf.P(`// Code generated by protoc-gen-orm-ent. DO NOT EDIT.`)
	gf.P(`// source: `, f.Desc.Path())
	gf.P("")
	gf.P("package ", pkg_name)
	gf.P("")

	return gf, path, nil
}
