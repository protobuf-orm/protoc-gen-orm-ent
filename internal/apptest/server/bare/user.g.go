// Code generated by protoc-gen-orm-ent. DO NOT EDIT.
// source: apptest/user.proto

package bare

import (
	context "context"
	sqlgraph "entgo.io/ent/dialect/sql/sqlgraph"
	uuid "github.com/google/uuid"
	apptest "github.com/protobuf-orm/protoc-gen-orm-ent/internal/apptest"
	ent "github.com/protobuf-orm/protoc-gen-orm-ent/internal/apptest/ent"
	predicate "github.com/protobuf-orm/protoc-gen-orm-ent/internal/apptest/ent/predicate"
	user "github.com/protobuf-orm/protoc-gen-orm-ent/internal/apptest/ent/user"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	time "time"
)

type UserServiceServer struct {
	Db *ent.Client
	apptest.UnimplementedUserServiceServer
}

func NewUserServiceServer(db *ent.Client) apptest.UserServiceServer {
	return UserServiceServer{Db: db}
}

func (s UserServiceServer) Add(ctx context.Context, req *apptest.UserAddRequest) (*apptest.User, error) {
	ds := make([]func(v *apptest.User), 0, 1)
	q := s.Db.User.Create()
	if req.HasId() {
		if v, err := uuid.FromBytes(req.GetId()); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "id: %s", err)
		} else {
			q.SetID(v)
		}
	} else {
		q.SetID(uuid.New())
	}
	if k, err := TenantGetKey(ctx, s.Db, req.GetTenant()); err != nil {
		return nil, err
	} else {
		q.SetTenantID(k)
		ds = append(ds, func(v *apptest.User) {
			v.SetTenant(apptest.Tenant_builder{Id: k[:]}.Build())
		})
	}
	if req.HasAlias() {
		q.SetAlias(req.GetAlias())
	} else {
		q.SetAlias("")
	}
	if req.HasName() {
		q.SetName(req.GetName())
	} else {
		q.SetName("")
	}
	if u := req.GetLabels(); len(u) > 0 {
		q.SetLabels(u)
	}
	if req.HasLock() {
		q.SetLock(req.GetLock())
	}
	if req.HasDateCreated() {
		q.SetDateCreated(req.GetDateCreated().AsTime())
	} else {
		q.SetDateCreated(time.Now().UTC())
	}

	u, err := q.Save(ctx)
	if err != nil {
		if err, ok := err.(*ent.ConstraintError); ok && sqlgraph.IsUniqueConstraintError(err) {
			return nil, status.Errorf(codes.AlreadyExists, "User already exists: %s", err.Unwrap())
		}
		return nil, err
	}

	v := u.Proto()
	for _, d := range ds {
		d(v)
	}
	return v, nil
}

func (s UserServiceServer) Get(ctx context.Context, req *apptest.UserGetRequest) (*apptest.User, error) {
	q := s.Db.User.Query()

	if p, err := UserPick(req.GetRef()); err != nil {
		return nil, err
	} else {
		q.Where(p)
	}
	UserSelectInit(q, req.GetSelect())

	v, err := q.Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, status.Error(codes.NotFound, "User not found")
		}
		return nil, err
	}
	return v.Proto(), nil
}

func selectUserKey(q *ent.UserQuery) {
	q.Select(user.FieldID)
}

func UserSelectedFields(m *apptest.UserSelect) []string {
	if m.GetAll() {
		return user.Columns
	}

	vs := make([]string, 0, len(user.Columns))
	{
		vs = append(vs, user.FieldID)
	}
	if m.GetAlias() {
		vs = append(vs, user.FieldAlias)
	}
	if m.GetName() {
		vs = append(vs, user.FieldName)
	}
	if m.GetLabels() {
		vs = append(vs, user.FieldLabels)
	}
	if m.GetLock() {
		vs = append(vs, user.FieldLock)
	}
	if m.GetDateCreated() {
		vs = append(vs, user.FieldDateCreated)
	}

	return vs
}

func UserSelect(q *ent.UserQuery, m *apptest.UserSelect) {
	if !m.GetAll() {
		fields := UserSelectedFields(m)
		q.Select(fields...)
	}
	if m.HasTenant() {
		q.WithTenant(func(q *ent.TenantQuery) {
			TenantSelect(q, m.GetTenant())
		})
	}
}

func UserSelectInit(q *ent.UserQuery, m *apptest.UserSelect) {
	if m != nil {
		UserSelect(q, m)
	} else {
		q.WithTenant(selectTenantKey)
	}
}

func (s UserServiceServer) Patch(ctx context.Context, req *apptest.UserPatchRequest) (*apptest.User, error) {
	p, err := UserPick(req.GetTarget())
	if err != nil {
		return nil, err
	}

	q := s.Db.User.Update().Where(p)
	if req.HasAlias() {
		q.SetAlias(req.GetAlias())
	}
	if req.HasName() {
		q.SetName(req.GetName())
	}
	if u := req.GetLabels(); len(u) > 0 {
		q.SetLabels(req.GetLabels())
	}
	if req.GetLockNull() {
		q.ClearLock()
	} else if req.HasLock() {
		q.SetLock(req.GetLock())
	}

	if _, err := q.Save(ctx); err != nil {
		return nil, err
	}

	return nil, nil
}

func UserGetKey(ctx context.Context, db *ent.Client, ref *apptest.UserRef) (uuid.UUID, error) {
	var z uuid.UUID
	if ref.HasId() {
		if v, err := uuid.FromBytes(ref.GetId()); err != nil {
			return z, status.Errorf(codes.InvalidArgument, "id: %s", err)
		} else {
			return v, nil
		}
	}

	p, err := UserPick(ref)
	if err != nil {
		return z, err
	}

	v, err := db.User.Query().Where(p).OnlyID(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return z, status.Error(codes.NotFound, "User not found")
		}
		return z, err
	}

	return v, nil
}

func (s UserServiceServer) Erase(ctx context.Context, req *apptest.UserRef) (*emptypb.Empty, error) {
	p, err := UserPick(req)
	if err != nil {
		return nil, err
	}

	if _, err := s.Db.User.Delete().Where(p).Exec(ctx); err != nil {
		return nil, err
	}
	return nil, nil
}

func UserPick(req *apptest.UserRef) (predicate.User, error) {
	switch req.WhichKey() {
	case apptest.UserRef_Id_case:
		if v, err := uuid.FromBytes(req.GetId()); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "id: %s", err)
		} else {
			return user.IDEQ(v), nil
		}
	case apptest.UserRef_Alias_case:
		k := req.GetAlias()
		ps := make([]predicate.User, 0, 2)
		ps = append(ps, user.AliasEQ(k.GetAlias()))
		if p, err := TenantPick(k.GetTenant()); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "alias.tenant: %s", err)
		} else {
			ps = append(ps, user.HasTenantWith(p))
		}
		return user.And(ps...), nil
	case apptest.UserRef_Key_not_set_case:
		return nil, status.Errorf(codes.InvalidArgument, "key not set")
	default:
		return nil, status.Errorf(codes.Unimplemented, "unknown type of key: %s", req.WhichKey())
	}
}
