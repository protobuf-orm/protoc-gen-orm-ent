// Code generated by protoc-gen-orm-ent. DO NOT EDIT.
// source: apptest/user.proto

package bare

import (
	context "context"
	uuid "github.com/google/uuid"
	apptest "github.com/protobuf-orm/protoc-gen-orm-ent/internal/apptest"
	ent "github.com/protobuf-orm/protoc-gen-orm-ent/internal/apptest/ent"
	predicate "github.com/protobuf-orm/protoc-gen-orm-ent/internal/apptest/ent/predicate"
	user "github.com/protobuf-orm/protoc-gen-orm-ent/internal/apptest/ent/user"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	time "time"
)

type UserServiceServer struct {
	Db *ent.Client
	apptest.UnimplementedUserServiceServer
}

func NewUserServiceServer(db *ent.Client) apptest.UserServiceServer {
	return UserServiceServer{Db: db}
}

func (s UserServiceServer) Add(ctx context.Context, req *apptest.UserAddRequest) (*apptest.User, error) {
	q := s.Db.User.Create()
	if req.HasId() {
		if v, err := uuid.FromBytes(req.GetId()); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "id: %s", err)
		} else {
			q.SetID(v)
		}
	} else {
		q.SetID(uuid.New())
	}
	if k, err := TenantGetKey(ctx, s.Db, req.GetTenant()); err != nil {
		return nil, err
	} else {
		q.SetTenantID(k)
	}
	if req.HasAlias() {
		q.SetAlias(req.GetAlias())
	} else {
		q.SetAlias("")
	}
	if req.HasName() {
		q.SetName(req.GetName())
	} else {
		q.SetName("")
	}
	if u := req.GetLabels(); len(u) > 0 {
		q.SetLabels(u)
	}
	if req.HasLock() {
		q.SetLock(req.GetLock())
	}
	if req.HasDateCreated() {
		q.SetDateCreated(req.GetDateCreated().AsTime())
	} else {
		q.SetDateCreated(time.Now().UTC())
	}

	v, err := q.Save(ctx)
	if err != nil {
		return nil, err
	}

	return v.Proto(), nil
}

func (s UserServiceServer) Get(ctx context.Context, req *apptest.UserGetRequest) (*apptest.User, error) {
	q := s.Db.User.Query()

	if p, err := UserPick(req.GetRef()); err != nil {
		return nil, err
	} else {
		q.Where(p)
	}

	if s := req.GetSelect(); s != nil {
		// TODO
	} else {
		q.WithTenant(selectTenantKey)
	}

	v, err := q.Only(ctx)
	if err != nil {
		return nil, err
	}
	return v.Proto(), nil
}

func selectUserKey(q *ent.UserQuery) {
	q.Select(user.FieldID)
}

func (s UserServiceServer) Patch(ctx context.Context, req *apptest.UserPatchRequest) (*apptest.User, error) {
	p, err := UserPick(req.GetTarget())
	if err != nil {
		return nil, err
	}

	q := s.Db.User.Update().Where(p)
	if req.HasAlias() {
		q.SetAlias(req.GetAlias())
	}
	if req.HasName() {
		q.SetName(req.GetName())
	}
	if u := req.GetLabels(); len(u) > 0 {
		q.SetLabels(req.GetLabels())
	}
	if req.GetLockNull() {
		q.ClearLock()
	} else if req.HasLock() {
		q.SetLock(req.GetLock())
	}

	if _, err := q.Save(ctx); err != nil {
		return nil, err
	}

	return nil, nil
}

func UserGetKey(ctx context.Context, db *ent.Client, ref *apptest.UserRef) (uuid.UUID, error) {
	var z uuid.UUID
	if ref.HasId() {
		if v, err := uuid.FromBytes(ref.GetId()); err != nil {
			return z, status.Errorf(codes.InvalidArgument, "id: %s", err)
		} else {
			return v, nil
		}
	}

	p, err := UserPick(ref)
	if err != nil {
		return z, nil
	}

	v, err := db.User.Query().Where(p).OnlyID(ctx)
	if err != nil {
		return z, err
	}

	return v, nil
}

func (s UserServiceServer) Erase(ctx context.Context, req *apptest.UserRef) (*emptypb.Empty, error) {
	p, err := UserPick(req)
	if err != nil {
		return nil, err
	}

	if _, err := s.Db.User.Delete().Where(p).Exec(ctx); err != nil {
		return nil, err
	}
	return nil, nil
}

func UserPick(req *apptest.UserRef) (predicate.User, error) {
	switch req.WhichKey() {
	case apptest.UserRef_Id_case:
		if v, err := uuid.FromBytes(req.GetId()); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "id: %s", err)
		} else {
			return user.IDEQ(v), nil
		}
	case apptest.UserRef_Alias_case:
		k := req.GetAlias()
		ps := make([]predicate.User, 0, 2)
		ps = append(ps, user.AliasEQ(k.GetAlias()))
		if p, err := TenantPick(k.GetTenant()); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "alias.tenant: %s", err)
		} else {
			ps = append(ps, user.HasTenantWith(p))
		}
		return user.And(ps...), nil
	default:
		return nil, status.Errorf(codes.InvalidArgument, "unknown type of key: %s", req.WhichKey())
	}
}
